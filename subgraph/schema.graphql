type Appraisal @entity {
  id: Bytes!
  appraiser: Bytes! # address
  nftId: BigInt! # uint256
  nftContract: Bytes!
  conductorId: BigInt! # uint256
  appraisalId: BigInt! # uint256
  overallScore: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  tokenType: Int!
  transactionHash: Bytes!
  uri: String!
  reactions: [ReactionUsage!]
  metadata: Metadata
  conductor: Conductor
}

type Metadata @entity {
  id: String!
  comment: String!
  reactions: [ResponseMetadata!]
}

type ResponseMetadata @entity {
  id: String!
  emoji: String!
  count: BigInt!
}

type ReactionUsage @entity {
  id: Bytes!
  reaction: Reaction
  count: BigInt!
}

type NFT @entity {
  id: Bytes!
  nftId: BigInt! # uint256
  nftContract: Bytes! # address
  tokenId: BigInt! # uint256
  submitter: Bytes! # address
  tokenType: Int! # uint8
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  active: Boolean!
  appraisalCount: BigInt!
  totalScore: BigInt!
  averageScore: BigInt!
  appraisals: [Appraisal!]
}

type Conductor @entity {
  id: Bytes!
  metadata: BaseMetadata
  conductorId: BigInt! # uint256
  uri: String # string
  blockNumber: BigInt
  blockTimestamp: BigInt
  transactionHash: Bytes
  appraisalCount: BigInt
  totalScore: BigInt
  averageScore: BigInt
  reviewCount: BigInt
  totalReviewScore: BigInt
  averageReviewScore: BigInt
  inviteCount: BigInt
  availableInvites: BigInt
  appraisals: [Appraisal!]
  reviews: [Review!]
  invitedDesigners: [Designer!]
  notAppraised: [NFT!]
}

type Reviewer @entity {
  id: Bytes!
  wallet: Bytes!
  uri: String
  metadata: BaseMetadata
  reviews: [Review!]
  reviewCount: BigInt
  totalScore: BigInt
  averageScore: BigInt
  transactionHash: Bytes
  blockTimestamp: BigInt
  lastReviewTimestamp: BigInt
}

type Review @entity {
  id: Bytes!
  reviewer: Reviewer
  reviewId: BigInt!
  conductorId: BigInt!
  conductor: Conductor
  reviewScore: BigInt!
  timestamp: BigInt!
  uri: String!
  metadata: Metadata
  reactions: [ReactionUsage!]
}

type Designer @entity {
  id: Bytes!
  wallet: Bytes!
  metadata: BaseMetadata
  invitedBy: Conductor
  active: Boolean!
  designerId: BigInt!
  inviteTimestamp: BigInt!
  packCount: BigInt!
  reactionPacks: [ReactionPack!]
  uri: String
}

type Reaction @entity {
  id: Bytes!
  reactionId: BigInt!
  packId: BigInt!
  pack: ReactionPack
  reactionUri: String!
  reactionMetadata: ReactionMetadata
  tokenIds: [BigInt!]
}

type ReactionPack @entity {
  id: Bytes!
  designer: Bytes!
  designerProfile: Designer
  packId: BigInt!
  currentPrice: BigInt!
  maxEditions: BigInt!
  soldCount: BigInt!
  basePrice: BigInt!
  priceIncrement: BigInt!
  conductorReservedSpots: BigInt!
  active: Boolean!
  blockTimestamp: BigInt!
  packUri: String!
  packMetadata: BaseMetadata
  reactions: [Reaction!]!
  purchases: [Purchase!]
}

type Purchase @entity {
  id: Bytes!
  buyer: Bytes!
  purchaseId: BigInt!
  packId: BigInt!
  price: BigInt!
  editionNumber: BigInt!
  shareWeight: BigInt!
  timestamp: BigInt!
  transactionHash: Bytes!
  pack: ReactionPack
}

type TokenReaction @entity {
  id: Bytes!
  tokenId: BigInt!
  reaction: Reaction!
}

type BaseMetadata @entity {
  id: String!
  title: String!
  image: String
  description: String
}

type ReactionMetadata @entity {
  id: String!
  title: String!
  image: String
  description: String
  model: String
  workflow: String
  prompt: String
}

type ConductorRegistry @entity {
  id: String!
  conductorIds: [BigInt!]!
}
type Approval @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ApprovalForAll @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MintersAuthorized @entity(immutable: true) {
  id: Bytes!
  minters: [Bytes!]! # tuple[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokenMinted @entity(immutable: true) {
  id: Bytes!
  minter: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TokenURIUpdated @entity(immutable: true) {
  id: Bytes!
  reason: BigInt! # uint256
  uri: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Transfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
